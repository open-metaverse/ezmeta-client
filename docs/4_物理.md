# Fusion 2 - 4 - 物理 | Photon Engine

 

This document is about: **FUSION 2**

SWITCH TO

[FUSION 2-SHARED](/ja-jp/fusion/2-shared/fusion-shared-intro) [FUSION 1](/ja-jp/fusion/v1/tutorials/host-mode-basics/4-physics) [FUSION 2](/ja-jp/fusion/current/tutorials/host-mode-basics/4-physics)

# 4 - 物理

## 概要

ここでは、サーバー主導（Server Authoritative）のゲームでFusionとPhysXを連携する方法を説明します。

この章では、物理挙動をするボールをスポーンしたり触れたりする方法を学びます。

## セットアップ

Fusionのデフォルトでは、物理シミュレーションはホスト上で実行され、クライアントはそれに従います。しかし、ローカル上で予測して動作するオブジェクトと、ホストに従って動作する物理オブジェクトとで、異なる時間軸で動作するオブジェクト同士が衝突する時、物理シミュレーションには問題が発生します。

「時間差」の解決は複雑なトピックです。うまくハックして隠蔽したり、一般的なアプリケーションでは負荷が高すぎる処理が必要だったり、プレイヤーへの即時のフィードバックをあきらめたり、様々な方法があります。残念ながら、あらゆるケースで有効なシンプルな解決方法は存在しません。

このチュートリアルでは、Fusionの[Physicsアドオン](/ja-jp/fusion/current/addons/physics/overview)を使用して、物理オブジェクトをローカル上で予測し、物理オブジェクトとプレイヤーアバターを同じ時間軸で動作させます。これは実用的で堅牢なソリューションですが、PhysXで予測と再シミュレーションを（ティックごとに複数回）実行するのは負荷が高いことを覚えておいてください。

Physicsアドオンは、[Download](/ja-jp/fusion/current/addons/physics/download)ページからダウンロードして、プロジェクトにインポートしてください。

## 物理オブジェクト

PhysXで制御されるネットワークオブジェクトは、通常のUnityと同じ`Rigidbody`とは別に、`NetworkRigidbody`と呼ばれるFusionの同期コンポーネントも追加します。`NetworkTransform`は`NetworkRigidbody`に置き換えられます。

1.  新規で空のゲームオブジェクトを作成する
2.  上記の名前を`PhysxBall`にする
3.  上記に`NetworkRigidbody3D`コンポーネントを追加する（自動的に`Rigidbody`も追加される）
4.  `NetworkObject`が不足している警告が表示されるので、`Add Network Object`を押す
5.  `PhysxBall`の子オブジェクトとして、`Sphere`を追加する
6.  上記のスケールを`0.2`にする
7.  上記を親オブジェクト`PhysxBall`の`NetworkRigdbody3D`の`InterpolationTarget`にドラッグする
8.  上記から`Collider`を削除する
9.  `PhysxBall`側に`SphereCollider`を追加し、半径を`0.1`にすることで`Sphere`と見た目を合わせる
10.  `PhysxBall`に新規スクリプトを追加し、名前を`PhysxBall.cs`にする
11.  上記オブジェクトをプロジェクトフォルダにドラッグし、プレハブを作成する
12.  シーンを保存してネットワークオブジェクトをベイクし、シーンから`PhysxBall`を削除する

![Ballプレハブ](/docs/img/fusion/v2/fusion-100/fusion-104-ballprefab.png)
Ballプレハブ

物理オブジェクトは、オブジェクトとビジュアル表現を分けて、ビジュアル表現を`InterpolationTarget`に設定することを推奨されますが、必須ではありません。`Rigidbody`や`Collider`は、`NetworkRigidbody`が付いている親オブジェクトに追加する必要があります。

## PhysxBall スクリプト

ボールはPhysXで制御され、ネットワーク周りは`NetworkRigidbody`が面倒を見てくれるため、キネマティックボールに比べて記述する必要があるコード量は少なくなります。`PhysxBall.cs`に記述する必要があるのは、数秒後にボールをデスポーンするための（キネマティックボールと全く同様の）タイマーと、初速度を設定するメソッドだけです。

これらは両方とも`Init()`メソッドで、以下のように記述します。

C#

```csharp
using UnityEngine;
using Fusion;

public class PhysxBall : NetworkBehaviour
{
  [Networked] private TickTimer life { get; set; }

  public void Init(Vector3 forward)
  {
    life = TickTimer.CreateFromSeconds(Runner, 5.0f);
    GetComponent<Rigidbody>().velocity = forward;
  }

  public override void FixedUpdateNetwork()
  {
    if(life.Expired(Runner))
      Runner.Despawn(Object);
  }
}
```

## 入力

ボールをスポーンするために、キネマティックボールと同様のステップに従ってコードを記述する必要があります。ただし、ボタンはマウス左ボタンのかわりにマウス右ボタンを使用します。

### 1\. NetworkInputData

`NetworkInputData.cs`で新しいボタンのフラグを追加します。

C#

```csharp
using Fusion;
using UnityEngine;

public struct NetworkInputData : INetworkInput
{
  public const byte MOUSEBUTTON0 = 1;
  public const byte MOUSEBUTTON1 = 2;

  public NetworkButtons buttons;
  public Vector3 direction;
}
```

### 2\. BasicSpawner

`BasicSpawner.cs`でマウス右ボタンをポーリングして、以下のようにフラグを設定します。

C#

```csharp
private bool _mouseButton0;
private bool _mouseButton1;
private void Update()
{
  _mouseButton0 = _mouseButton0 || Input.GetMouseButton(0);
  _mouseButton1 = _mouseButton1 || Input.GetMouseButton(1);
}

public void OnInput(NetworkRunner runner, NetworkInput input)
{
  var data = new NetworkInputData();

  data.buttons.Set(NetworkInputData.MOUSEBUTTON0, _mouseButton0);
  _mouseButton0 = false;
  data.buttons.Set(NetworkInputData.MOUSEBUTTON1, _mouseButton1);
  _mouseButton1 = false;

  input.Set(data);
}
```

### 3\. Player

`Player.cs`で実際にボールをスポーンするコードを記述するため、以下のようなプレハブの参照を追加します。

C#

```csharp
[SerializeField] private PhysxBall _prefabPhysxBall;
```

`Player`では先ほど作成した`Init()`メソッドを使用して、ボールのスポーンと初速度の設定を行います。

C#

```csharp
public override void FixedUpdateNetwork()
{
  if (GetInput(out NetworkInputData data))
  {
    data.direction.Normalize();
    _cc.Move(5*data.direction*Runner.DeltaTime);

    if (data.direction.sqrMagnitude > 0)
      _forward = data.direction;

    if (HasStateAuthority && delay.ExpiredOrNotRunning(Runner))
    {
      if (data.buttons.IsSet(NetworkInputData.MOUSEBUTTON0))
      {
        delay = TickTimer.CreateFromSeconds(Runner, 0.5f);
        Runner.Spawn(_prefabBall,
          transform.position+_forward,
          Quaternion.LookRotation(_forward),
          Object.InputAuthority,
          (runner, o) =>
          {
            // Initialize the Ball before synchronizing it
            o.GetComponent<Ball>().Init();
          });
      }
      else if (data.buttons.IsSet(NetworkInputData.MOUSEBUTTON1))
      {
        delay = TickTimer.CreateFromSeconds(Runner, 0.5f);
        Runner.Spawn(_prefabPhysxBall,
          transform.position+_forward,
          Quaternion.LookRotation(_forward),
          Object.InputAuthority,
          (runner, o) =>
          {
            o.GetComponent<PhysxBall>().Init( 10*_forward );
          });
      }
    }
  }
}
```

物理演算をネットワークに対応させるには、`NetworkRunner`オブジェクトに`RunnerSimulatePhysics3D`コンポーネントが必要です。`BasicSpawner.cs`の`StartGame`メソッド内で`NetworkRunner`コンポーネントを追加した後に、以下のようなコードを追加してください。

C#

```csharp
gameObject.AddComponent<RunnerSimulatePhysics3D>();
```

最後に、ボールのプレハブを`Player`プレハブの`_prefabPhysxBall`にアタッチした後、ビルドしてボールのテストを実行しましょう。

**次は [ホストモード入門 5 - プロパティの変更](/ja-jp/fusion/current/tutorials/host-mode-basics/5-property-changes)**

[Back to top](#)

-   [概要](#section)
-   [セットアップ](#section-1)
-   [物理オブジェクト](#section-2)
-   [PhysxBall スクリプト](#physxball)
-   [入力](#section-3)

-   [1\. NetworkInputData](#networkinputdata)
-   [2\. BasicSpawner](#basicspawner)
-   [3\. Player](#player)

## Embedded Content

nfl

---
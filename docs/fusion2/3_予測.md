# Fusion 2 - 3 - 予測 | Photon Engine

 

This document is about: **FUSION 2**

SWITCH TO

[FUSION 2-SHARED](/ja-jp/fusion/2-shared/fusion-shared-intro) [FUSION 1](/ja-jp/fusion/v1/tutorials/host-mode-basics/3-prediction) [FUSION 2](/ja-jp/fusion/current/tutorials/host-mode-basics/3-prediction)

# 3 - 予測

## 概要

ここでは、サーバー主導（Server Authoritative）のネットワークゲームでクライアントサイド予測を使用して、クライアントへ即時のフィードバックを与える方法を説明します。

この章では、予測で動くキネマティック（Kinematic）なボールをスポーンする方法を学びます。

## キネマティックオブジェクト

まず、スポーンするオブジェクトのプレハブを作成しましょう。

1.  新規で空のゲームオブジェクトを作成する
2.  上記の名前を`Ball`にする
3.  上記に`NetworkTransform`コンポーネントを追加する
4.  `NetworkObject`が不足している警告が表示されるので、`Add Network Object`を押す
5.  `Ball`の子オブジェクトとして、`Sphere`を追加する
6.  上記のスケールを`0.2`にする
7.  上記から`Collider`を削除する
8.  `Ball`側に`SphereCollider`を追加し、半径を`0.1`にすることで`Sphere`と見た目を合わせる
9.  `Ball`に新規スクリプトを追加し、名前を`Ball.cs`にする
10.  上記オブジェクトをプロジェクトフォルダにドラッグし、プレハブを作成する
11.  シーンを保存してネットワークオブジェクトをベイクし、シーンから`Ball`を削除する

![Ballプレハブ](/docs/img/fusion/v2/fusion-100/fusion-103-ballprefab.png)
Ballプレハブ

## 予測動作

目標は、全てのピア上で`Ball`が同時に同様の挙動を取るようにすることです。

ここでいう「同時」とは「同じティック上で」という意味で、現実世界の時間での同時とは異なります。これを実現する方法は、以下の通りです。

1.  サーバーは、一定の等間隔でシミュレーションを実行し、そのティックごとに`FixedUpdateNetwork()`を呼び出します。ティックを進める処理は、常にサーバーのみで行われます。これはUnity標準の`FixedUpdate()`と同じような挙動です。サーバーは各ティックで計算を終えた後、直前のティックとの状態の差分を圧縮し、ブロードキャストで送信します。
2.  クライアントは、上記のスナップショットを定期的な間隔で受信しますが、当然サーバーより常に遅延したものになります。クライアントはスナップショットを受信すると、内部の状態をスナップショットのティックまで戻した後、すぐにそのティックからクライアントの現在ティックまでの再シミュレーションを実行します。
3.  クライアントの現在ティックは、常にサーバーより十分な余裕をとって先行しています。ユーザーから収集した入力は、サーバーが（クライアントの現在ティックと）同じティックになる前にサーバーに到達するため、サーバー側で正しく入力が適用されることになります。

これは、いくつかの意味合いも含まれます。

1.  クライアントは、フレームごとに何度も`FixedUpdateNetwork()`が実行されます。また、最新のスナップショットを受信するたびに、同一のティックのシミュレーションが何度も実行されます。ネットワーク上の状態は`FixedUpdateNetwork()`が呼び出される前にFusionによって直前のティックへ自動的にリセットされますが、ローカル上の状態はその限りではないので十分な注意が必要になります。
2.  各ピアは、あらゆるオブジェクトの未来の状態（位置・速度・加速度・その他の決定論的なプロパティなど）を予測できます。他のプレイヤーの入力は予測できないため、その予測は失敗する可能性があります。
3.  クライアントのローカルの入力は、すぐに適用されて即時のフィードバックを得られますが、状態を変更する権限があるわけではありません。ローカルの入力の適用はあくまで予測であり、最終的なスナップショットを生成するのはサーバーです。

上記を念頭に置いて、作業を進めていきましょう。`Ball`スクリプトを開き、`MonoBehaviour`を`NetworkBehaviour`に変更して、`FixedUpdateNetwork()`メソッドを追加してください。

今回のシンプルな例では、`Ball`は一定の速度で5秒間前進した後、自らをデスポーンします。まず以下のように、オブジェクトに単純な直線運動を追加しましょう。

C#

```csharp
using Fusion;

public class Ball : NetworkBehaviour
{
  public override void FixedUpdateNetwork()
  {
    transform.position += 5 * transform.forward * Runner.DeltaTime;
  }
}
```

これは通常のUnityのオブジェクトを移動させるコードとほぼ同じですが、タイムステップは`Time.deltaTime`ではなくティック間の時間に該当する`Runner.DeltaTime`になっています。Unityの`transform`の変更がネットワーク上で同期されているのは`NetworkTransform`のおかげです。`NetworkTransform`は、`transform`をネットワーク上の状態にするための便利なコンポーネントです。

現状はボールが無限に飛んでいってしまうので、設定した時間が経過した後にオブジェクトをデスポーンするコードが必要です。Fusionは`TickTimer`というタイマー用の便利な型を提供しています。現在の残り時間を格納するかわりに終了時間のティックを格納すると、タイマーは毎ティック同期する必要がなくなり、タイマー作成時一度のみの同期で済むようになります。

`TickTimer`を追加するために、`Ball`に`TickTimer`型の`life`という名前のプロパティを追加し、getterとsetterの空スタブと`[Networked]`属性を追加します。

C#

```csharp
[Networked] private TickTimer life { get; set; }
```

`[Networked]`属性が付いたプロパティと`{get; set;}`スタブは、Fusionの（自動的な）シリアライゼーションのコード生成に使用されます。必ず上記パターンに従ったコードを記述してください。

タイマーはオブジェクトをスポーンする前に設定したい所ですが、`Spawned()`はローカル上でオブジェクトがスポーンした直後に呼び出されるため、ネットワーク上の状態の初期化の使用には適しません。

`Spawned()`のかわりに、プレイヤー側から呼び出すことができる`Init()`メソッドを作成し、`life`プロパティを5秒先に設定する際に使用できるようにしておきます。これには`TickTimer`の`CreateFromeSeconds()`という静的メソッドが最適です。

C#

```csharp
public void Init()
{
  life = TickTimer.CreateFromSeconds(Runner, 5.0f);
}
```

最後に、`FixedUpdateNetwork()`でタイマーが切れているかどうかを確認します。  
タイマーが切れたら、ボールのデスポーン処理を行います。

C#

```csharp
if(life.Expired(Runner))
  Runner.Despawn(Object);
```

完全な`Ball`クラスは以下のようになります。

C#

```csharp
using Fusion;

public class Ball : NetworkBehaviour
{
  [Networked] private TickTimer life { get; set; }

  public void Init()
  {
    life = TickTimer.CreateFromSeconds(Runner, 5.0f);
  }

  public override void FixedUpdateNetwork()
  {
    if(life.Expired(Runner))
      Runner.Despawn(Object);
    else
      transform.position += 5 * transform.forward * Runner.DeltaTime;
  }
}
```

## プレハブのスポーン

ボールプレハブのスポーンは、プレイヤーアバターのスポーンと同じです。ただし、プレイヤーアバターのスポーンはネットワークのイベント（プレイヤーのセッションへの参加）が起点になるのに対して、ボールのスポーンはユーザーの入力が起点になります。

これを動かすためには、入力構造体に追加のデータが必要です。以下の三つの手順を行ってください。

1.  入力構造体にデータを追加する
2.  Unity側の入力からデータを収集する
3.  プレイヤーアバターの`FixedUpdateNetwork()`で入力を適用する

`NetworkInputData`を開き、`buttons`というバイトフィールドを新規に追加し、マウス左ボタンを指す定数を定義します。

C#

```csharp
using Fusion;
using UnityEngine;

public struct NetworkInputData : INetworkInput
{
    public const byte MOUSEBUTTON0 = 1;

    public NetworkButtons buttons;
    public Vector3 direction;
}
```

`NeyworkButtons`型はFusionで定義されている型で、複数のボタン入力状態の追跡に便利で、帯域幅使用量も最適化されています。

`BasicSpawner`を開き`OnInput()`メソッドに移動し、マウス左ボタン用のチェックを追加して、ボタンが押されている間は`buttons`の最初のビットを立てます。素早いクリックを見逃すことのないように、マウスボタンは`Update()`でサンプリングして、入力構造体に格納した後にリセットします。

C#

```csharp
private bool _mouseButton0;
private void Update()
{
  _mouseButton0 = _mouseButton0 | Input.GetMouseButton(0);
}

public void OnInput(NetworkRunner runner, NetworkInput input)
{
  var data = new NetworkInputData();

  if (Input.GetKey(KeyCode.W))
    data.direction += Vector3.forward;

  if (Input.GetKey(KeyCode.S))
    data.direction += Vector3.back;

  if (Input.GetKey(KeyCode.A))
    data.direction += Vector3.left;

  if (Input.GetKey(KeyCode.D))
    data.direction += Vector3.right;

  data.buttons.Set( NetworkInputData.MOUSEBUTTON0, _mouseButton0);
  _mouseButton0 = false;

  input.Set(data);
}
```

`Player`クラスを開き、`GetInput()`の中でボタンの押下をチェックして、プレハブをスポーンします。プレハブは、Unityのインスペクターからアタッチされる`[SerializeField]`で渡されます。プレイヤーアバターの向いている方向にボールをスポーンできるようにするため、変数に記録した直前の移動方向をボールの進行方向に使用します。

C#

```csharp
[SerializeField] private Ball _prefabBall;

private Vector3 _forward = Vector3.forward;

if (GetInput(out NetworkInputData data))
{
  if (data.direction.sqrMagnitude > 0)
    _forward = data.direction;
  if (data.buttons.IsSet(NetworkInputData.MOUSEBUTTON0))
  {
      Runner.Spawn(_prefabBall,
      transform.position+_forward, Quaternion.LookRotation(_forward),
      Object.InputAuthority);
  }
}
```

ボールのスポーン頻度を制限するため、スポーンごとに制限タイマーを設定します。タイマーはボタンの押下を検出した時にリセットします。

C#

```csharp
[Networked] private TickTimer delay { get; set; }

if (HasStateAuthority && delay.ExpiredOrNotRunning(Runner))
{
  if (data.buttons.IsSet(NetworkInputData.MOUSEBUTTON0))
  {
    delay = TickTimer.CreateFromSeconds(Runner, 0.5f);
    Runner.Spawn(_prefabBall,
    transform.position+_forward, Quaternion.LookRotation(_forward),
    Object.InputAuthority);
  }
}
```

`NetworkObject`をスポーンできるのは`StateAuthority`を持つホストのみなので、`StateAuthority`のチェックが必要です。プレイヤーアバターの移動とは異なり、ボールのスポーンのクライアントサイド予測は行われません。

まだボールの初期化処理を行っていないため、`Spawn`の呼び出しに微調整が必要です。具体的には、先ほど定義した`Init()`メソッドを呼び出して、タイマーを適切に初期化しなければなりません。

`Spawn()`の引数には、プレハブがインスタンス化された後かつ、プレハブが同期される前に呼び出されるコールバックが提供されています。

まとめると、クラスの実装は以下のようになります。

C#

```csharp
using Fusion;
using UnityEngine;

public class Player : NetworkBehaviour
{
  [SerializeField] private Ball _prefabBall;

  [Networked] private TickTimer delay { get; set; }

  private NetworkCharacterController _cc;
  private Vector3 _forward;

  private void Awake()
  {
    _cc = GetComponent<NetworkCharacterController>();
    _forward = transform.forward;
  }

  public override void FixedUpdateNetwork()
  {
    if (GetInput(out NetworkInputData data))
    {
      data.direction.Normalize();
      _cc.Move(5*data.direction*Runner.DeltaTime);

      if (data.direction.sqrMagnitude > 0)
        _forward = data.direction;

      if (HasStateAuthority && delay.ExpiredOrNotRunning(Runner))
      {
        if (data.buttons.IsSet(NetworkInputData.MOUSEBUTTON0))
        {
          delay = TickTimer.CreateFromSeconds(Runner, 0.5f);
            Runner.Spawn(_prefabBall,
            transform.position+_forward, Quaternion.LookRotation(_forward),
            Object.InputAuthority, (runner, o) =>
            {
              // Initialize the Ball before synchronizing it
              o.GetComponent<Ball>().Init();
            });
        }
      }
    }
  }
}
```

テストを行う前に、`Player`プレハブの`_prefabBall`にボールプレハブをアタッチしておくことを忘れないようにしましょう。プロジェクトの`PlayerPrefab`を選択して、`Ball`プレハブを`_prefabBall`にドラッグしてください。

**次は [ホストモード入門 4 - 物理](/ja-jp/fusion/current/tutorials/host-mode-basics/4-physics)**

[Back to top](#)

-   [概要](#section)
-   [キネマティックオブジェクト](#section-1)
-   [予測動作](#section-2)
-   [プレハブのスポーン](#section-3)

## Embedded Content

nfl

---